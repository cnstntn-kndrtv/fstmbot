# FSTM bot with some NLP functions and knowledges

## Запуск  
для парсинга знаний (knowledges.js парсится и превращается в knowledges.ttl) и загрузки базы знаний - levelGraph (llevelDB) в папке ./knowledgeDB

    npm run cleanup

и дальше 

    node app

## Отображение правил
    node utils/createView
обновляет файл для правил в ./view/triples.js  
и запускаем файл ./view/index.hmtl


## Разум
у бота есть 2 типа разума:  

 - коллективный - те, что заданы по умолчанию. Лежат в папке lib/bot/collective-mind  
 - разум конкретного бота (приложения) в ./mind  

Разум. Что за ...?  
  

## Правила (rules.js)  
Правила бота описаны в файле rules.js  
Коллективные правила содержат только одно - ответ по умолчанию, находятся в папке ./lib/bot/collective-mind  
Правила для приложения - в папке ./mind  
Правила - массив объектов.  
каждый объект выглядит так:  

    {
        input: 'привет', // массив, или строка токены из вопорса пользователя, на которое должно сработать правило
        inputContext: null, // входной контекст - строка
        nextContext: 'привет', // выходной контекст - строка
        response: ['здарова'], // ответ - строка или массив
        action: function() { // действия правила
                    // действия бота описаны ниже. 
                    // если это действия приложения - вызываются через this.actions.назавние
                    // если дефолтные правила (те, что из ./lib/bot/collective-mind) то через this.actions.default.name
                    // нужно передавать this - текущее правило, чтобы в той функции иметь доступ к телу бота
                    this.actions.myFunction(this, 'some param');
                }, 
    },


Токены - это либо слова, либо управляющие токены, на которые сработает правило.  
Управляющие токены:  
 ^класс - это класс - класс из знания бота  
 _черепный - стемма слова
 ?:типВпроса - тип вопроса (пока не реализован)  


##Знания (knowledges.js / knowledges.ttl)
знания изначально описаны в файле knowledges.js - это объект, который имеет вид:
  
    module.exports = {
        '^entity': ['^ингридиенты', ], // класс entity включает подкласс ^ингридиенты
        '^ингридиенты': ['^сыр', '^капуста', ], класс ^ингридиенты (подкласс ^entity) включает пару подклассов ^сыр и ^капуста
        '^сыр': ['сыр', 'гауда', 'бри', ], класс ^сыр (подкласс класса ^ингридиенты) включает пару инстансов - гауда. бри и сыр. почему сыр? это слово сыр, как обозначение любого сыра - сыр как сыр)
        '^капуста': 'брюссельская капуста',
    }

Для загрузки знаний в базу см пункт Запуск


## Действия (actions.js)
Это функции, который можно подгрузить боту, чтобы он их исполнял, когда срабатывает правило.

    module.exports = {
        myFunction: function(cr, param) {
            console.log(param);
            cr.bot.response = currentRule.response; // можно насильно поставить ответ - например после какой-ибудь обработки
            cr.bot.context = currentRule.nextContext; // можно установить контекст
            // cr.bot.question - текущий вопорс пользователя, разобранный
            // cr.bot.memory - память бота - СМ НИЖЕ
            // cr.bot.memory.previousQuestions - предыдущие ответы бота - массив с правилами и вопросами, которые были раньше. Можно вызывать через метод cr.bot.actions.default.getPreviousQuestions(cr, 1)
            // cr.bot.userID - текущий пользователь (имя инстанса бота)
        },

Принимает cr (current rule) - текущее правило - передавать обязательно, чтобы иметь доступ к телу бота.  
cr.bot.memory - память бота - можно записать какие-нибудь переменные для текущего диалога. Но не "длинные" данные. Например сюда стоит записать какие-нибудь параметры фильтрации товаров - они важны для этого конкретного диалога, а потом их можно благополучно забыть
но не, например, имя пользователя, или адрес - их лучше писать в базу knowledges - через дефолтную функцию cr.bot.actions.default.save(cr, key, value)

### Дефолтные действия
потом
## Структура проекта. Что за классы?
потом
